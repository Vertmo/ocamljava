<!DOCTYPE html>

<html>
<head>
<title>OCaml-Java: overview of the concurrent library</title>
<link href="../css/bootstrap.min.css" rel="stylesheet">
<link href="../css/syntax.css" rel="stylesheet">
<style>
table {
}
</style>
</head>
<body>

<div class="container">
  <div class="row">&nbsp;</row>
  <div class="row">
    <div class="col-xs-6 col-sm-3 sidebar">
      <div class="list-group">
        
        <a href="../index.html" class="list-group-item">
          <span class="glyphicon glyphicon-home" aria-hidden="true"></span>
          &nbsp;Main page
        </a>
        
        <a href="#abstraction-levels" class="list-group-item">
          <span class="glyphicon glyphicon-tag" aria-hidden="true"></span>
          &nbsp;Abstraction levels
        </a>
        
        <a href="#basics" class="list-group-item">
          <span class="glyphicon glyphicon-tag" aria-hidden="true"></span>
          &nbsp;Basics
        </a>
        
        <a href="#atomics" class="list-group-item">
          <span class="glyphicon glyphicon-tag" aria-hidden="true"></span>
          &nbsp;Atomics
        </a>
        
        <a href="#futures" class="list-group-item">
          <span class="glyphicon glyphicon-tag" aria-hidden="true"></span>
          &nbsp;Futures
        </a>
        
        <a href="#forkjoin-computations" class="list-group-item">
          <span class="glyphicon glyphicon-tag" aria-hidden="true"></span>
          &nbsp;Fork/join computations
        </a>
        
        <a href="#mapreduce-computations" class="list-group-item">
          <span class="glyphicon glyphicon-tag" aria-hidden="true"></span>
          &nbsp;Map/reduce computations
        </a>
        
        <a href="#parallel-arrays" class="list-group-item">
          <span class="glyphicon glyphicon-tag" aria-hidden="true"></span>
          &nbsp;Parallel arrays
        </a>
        
        <a href="#stm" class="list-group-item">
          <span class="glyphicon glyphicon-tag" aria-hidden="true"></span>
          &nbsp;STM
        </a>
        
      </div>
    </div>
    <div class="col-xs-12 col-sm-9">
      <h1>OCaml-Java: overview of the concurrent library</h1>
      <hr>
      <p>This page contains the information about the <code>concurrent</code> library that ships with the <em>alpha</em> version of OCaml-Java 2.0.</p>
<div class="alert alert-warning">
<p><strong>Warning!</strong> by default, OCaml-Java favors compatibility with the original OCaml implementation, meaning that it is based on a global runtime lock. In order to leverage the power of the <code>concurrent</code> library, it is necessary to disable the runtime lock by linking the program with the <kbd>-runtime-parameter runtime-lock=off</kbd> command-line option.</p>
</div>
<h1 id="abstraction-levels">Abstraction levels</h1>
<p>The <code>concurrent</code> library is a pack of several modules into the <code>Concurrent</code> module. These modules fall into nine categories of raising abstraction levels:</p>
<ul>
<li>basic thread manipulation (<code>Thread</code>, <code>ThreadGroup</code>, and <code>ThreadLocal</code> modules);</li>
<li>locks (<code>Lock</code>, <code>ReadWriteLock</code>, and <code>Condition</code> modules);</li>
<li>synchronization (<code>Semaphore</code>, <code>CountDownLatch</code>, <code>CyclicBarrier</code>, <code>Exchanger</code>, and <code>Phaser</code> modules);</li>
<li>atomic containers (see below);</li>
<li>futures (<code>Future</code>, <code>ScheduledFuture</code>, <code>ThreadPoolExecutor</code>, <code>ScheduledThreadPoolExecutor</code>, and <code>ExecutorCompletionService</code> modules);</li>
<li>fork/join computations (<code>ForkJoinPool</code>, and <code>ForkJoin</code> modules);</li>
<li>map/reduce computations (<code>MapReduce</code> module);</li>
<li>parallel operations over arrays (<code>ParallelArray</code> module);</li>
<li>minimalistic software transactional memory (<code>STM</code> module).</li>
</ul>
<h4 id="section"></h4>
<p>Besides these modules, <code>TimeUnit</code> defines the various time units and a conversion function.</p>
<h4 id="section-1"></h4>
<p>The <code>doc</code> directory of the binary distribution contains the <kbd>ocamldoc</kbd>-generated documentation for all modules. Most modules from the first five categories above are the counterparts of Java classes with the same name in the package <code>java.util.concurrent</code> (and its sub-packages). It is thus possible to get additional information from the JDK documentation.</p>
<h1 id="basics">Basics</h1>
<p>Threads created through the <code>Thread</code> module from the <code>concurrent</code> library are akin to those from the <code>Thread</code> module from the original OCaml distribution (in either <code>systhread</code>, or <code>thread</code> library). The three main differences are:</p>
<ul>
<li>that threads need to be first created and then started;</li>
<li>that a thread identifier can be recycled once a thread has terminated;</li>
<li>that threads can be organized in groups which form a tree-like structure.</li>
</ul>
<h4 id="section-2"></h4>
<p>Thread-local storage is available through the <code>ThreadLocal</code> module, and locks/conditions in the POSIX tradition are available through the <code>Lock</code>/<code>ReadWriteLock</code>/<code>Condition</code> modules. Advanced synchronization is provided through the following modules:</p>
<ul>
<li><code>Semaphore</code>;</li>
<li><code>Exchanger</code> for simple rendez-vous allowing to swap data between two threads;</li>
<li><code>CountDownLatch</code> for one-use barriers;</li>
<li><code>CyclicBarrier</code> for reusable barriers;</li>
<li><code>Phaser</code> for customizable barriers.</li>
</ul>
<h4 id="section-3"></h4>
<p>Here is an example of threads with a locally-stored accumulator variable:</p>
<div class="highlight">
<pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">acc</span> <span class="o">=</span> <span class="nn">ThreadLocal</span><span class="p">.</span><span class="n">make</span> <span class="mi">0</span> <span class="c">(* initial value *)</span>

<span class="k">let</span> <span class="n">compute</span> <span class="n">x</span> <span class="o">=</span>
  <span class="o">...</span>
  <span class="k">let</span> <span class="n">old</span> <span class="o">=</span> <span class="nn">ThreadLocal</span><span class="p">.</span><span class="n">get</span> <span class="n">acc</span> <span class="k">in</span> <span class="c">(* read access *)</span>
  <span class="o">...</span>
  <span class="nn">ThreadLocal</span><span class="p">.</span><span class="n">set</span> <span class="n">acc</span> <span class="o">(</span><span class="n">f</span> <span class="n">old</span><span class="o">)</span> <span class="c">(* write access *)</span>
  <span class="o">...</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
 <span class="k">let</span> <span class="n">threads</span> <span class="o">=</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">map</span>
      <span class="o">(</span><span class="k">fun</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="nn">Thread</span><span class="p">.</span><span class="n">make</span> <span class="n">compute</span> <span class="n">s</span><span class="o">)</span>
      <span class="o">[</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">5</span><span class="o">;</span> <span class="mi">7</span><span class="o">;</span> <span class="mi">11</span><span class="o">;</span> <span class="mi">13</span> <span class="o">]</span> <span class="k">in</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="nn">Thread</span><span class="p">.</span><span class="n">start</span> <span class="n">threads</span><span class="o">;</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="nn">Thread</span><span class="p">.</span><span class="n">join</span> <span class="n">threads</span></code></pre>
</div>
<h1 id="atomics">Atomics</h1>
<p>The atomic containers have module names that slightly differ from the equivalent Java class names, the complete mapping being given by the following table. All the atomic containers provide <em>compare-and-set</em> operations, thus allowing to write lock-free algorithms.</p>
<table class="table table-condensed table-striped">
<thead>
<tr class="header">
<th style="text-align: left;">OCaml module name</th>
<th style="text-align: left;">Java class name</th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>AtomicBool</code></td>
<td style="text-align: left;"><code>AtomicBoolean</code></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>AtomicInt32</code></td>
<td style="text-align: left;"><code>AtomicInteger</code></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>AtomicInt32Array</code></td>
<td style="text-align: left;"><code>AtomicIntegerArray</code></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>AtomicInt64</code></td>
<td style="text-align: left;"><code>AtomicLong</code></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>AtomicInt64Array</code></td>
<td style="text-align: left;"><code>AtomicLongArray</code></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>AtomicMarkableReference</code></td>
<td style="text-align: left;"><code>AtomicMarkableReference</code></td>
<td style="text-align: left;">(1)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>AtomicReference</code></td>
<td style="text-align: left;"><code>AtomicReference</code></td>
<td style="text-align: left;">(1)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>AtomicReferenceArray</code></td>
<td style="text-align: left;"><code>AtomicReferenceArray</code></td>
<td style="text-align: left;">(1)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>AtomicStampedReference</code></td>
<td style="text-align: left;"><code>AtomicStampedReference</code></td>
<td style="text-align: left;">(1)</td>
</tr>
</tbody>
</table>
<p>(1): physical comparison is used by the container. As OCaml-Java uses boxed values for OCaml <code>int</code> values, the container should not be used to store <code>int</code> values. Any other type can be safely stored (caching of <code>int</code> values ensure that sum types are correctly handled).</p>
<h4 id="section-4"></h4>
<p>Here is an example of atomic use, comparing the use of a bare <code>Pervasives.ref</code> value with an atomic one:</p>
<div class="highlight">
<pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="nn">Random</span><span class="p">.</span><span class="n">self_init</span> <span class="bp">()</span>

<span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="nn">AtomicInt64</span><span class="p">.</span><span class="n">make</span> <span class="mi">0</span><span class="n">L</span> <span class="c">(* accesses to the value are atomic *)</span>
<span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="n">L</span> <span class="c">(* accesses to the value are not atomic *)</span>

<span class="k">let</span> <span class="n">print</span> <span class="n">s</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="n">L</span> <span class="k">in</span>
  <span class="k">for</span> <span class="o">_</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">n</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="nn">Int64</span><span class="p">.</span><span class="n">of_int</span> <span class="o">(</span><span class="nn">Random</span><span class="p">.</span><span class="n">int</span> <span class="mi">250</span><span class="o">)</span> <span class="k">in</span>
    <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;%s (waiting %Ld)</span><span class="se">\n</span><span class="s2">%!&quot;</span> <span class="n">s</span> <span class="n">t</span><span class="o">;</span>
    <span class="n">b</span> <span class="o">:=</span> <span class="nn">Int64</span><span class="p">.</span><span class="n">add</span> <span class="o">!</span><span class="n">b</span> <span class="n">t</span><span class="o">;</span>
    <span class="n">l</span> <span class="o">:=</span> <span class="nn">Int64</span><span class="p">.</span><span class="n">add</span> <span class="o">!</span><span class="n">l</span> <span class="n">t</span><span class="o">;</span>
    <span class="n">ignore</span> <span class="o">(</span><span class="nn">AtomicInt64</span><span class="p">.</span><span class="n">add_and_get</span> <span class="n">a</span> <span class="n">t</span><span class="o">);</span>
    <span class="nn">Thread</span><span class="p">.</span><span class="n">sleep</span> <span class="n">t</span>
  <span class="k">done</span><span class="o">;</span>
  <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;l = %Ld</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">!</span><span class="n">l</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">10</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">threads</span> <span class="o">=</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">map</span>
      <span class="o">(</span><span class="k">fun</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="nn">Thread</span><span class="p">.</span><span class="n">make</span> <span class="o">(</span><span class="n">print</span> <span class="n">s</span><span class="o">)</span> <span class="n">n</span><span class="o">)</span>
      <span class="o">[</span> <span class="s2">&quot;hello&quot;</span><span class="o">;</span> <span class="s2">&quot;salut&quot;</span> <span class="o">]</span> <span class="k">in</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="nn">Thread</span><span class="p">.</span><span class="n">start</span> <span class="n">threads</span><span class="o">;</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="nn">Thread</span><span class="p">.</span><span class="n">join</span> <span class="n">threads</span><span class="o">;</span>
  <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;a = %Ld, b = %Ld</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="nn">AtomicInt64</span><span class="p">.</span><span class="n">get</span> <span class="n">a</span><span class="o">)</span> <span class="o">!</span><span class="n">b</span></code></pre>
</div>
<h1 id="futures">Futures</h1>
<p>Futures are similar to lazy values in the sense that, once created, it is possible to <em>wait</em> for their evaluation (though <code>Future.get</code>). However, they differ from lazy values as their evaluation is done in the background by another thread. Basic future manipulation is done through the <code>Future</code> module, but they are created by submitting a computation to a thread pool (by <code>submit</code>, or some <code>invoke</code> variant), as provided by the <code>ThreadPoolExecutor</code> module. Such pools need to be shutdown at program termination: as they contain threads, they prevent the JVM from ending the program (unless <code>exit</code> is explicitly called). Here is a basic example of future use:</p>
<div class="highlight">
<pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">pool</span> <span class="o">=</span>
  <span class="nn">ThreadPoolExecutor</span><span class="p">.</span><span class="n">make</span>
    <span class="o">~</span><span class="n">core_pool_size</span><span class="o">:</span><span class="mi">4</span><span class="n">l</span>
    <span class="o">~</span><span class="n">max_pool_size</span><span class="o">:</span><span class="mi">4</span><span class="n">l</span>
    <span class="mi">1</span><span class="n">L</span> <span class="nn">TimeUnit</span><span class="p">.</span><span class="nc">Seconds</span> <span class="c">(* keep-alive time for threads outside core *)</span>
    <span class="nn">RejectedExecutionHandler</span><span class="p">.</span><span class="nc">Discard_policy</span> <span class="c">(* how to handle rejected execution *)</span>

<span class="k">let</span> <span class="n">compute</span> <span class="n">x</span> <span class="o">=</span>
  <span class="o">...</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="nn">ThreadPoolExecutor</span><span class="p">.</span><span class="n">submit</span> <span class="n">pool</span> <span class="n">compute</span> <span class="mi">137</span> <span class="k">in</span>
  <span class="o">...</span>
  <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;result = %d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="nn">Future</span><span class="p">.</span><span class="n">get</span> <span class="n">f</span><span class="o">);</span>
  <span class="nn">ThreadPoolExecutor</span><span class="p">.</span><span class="n">shutdown</span> <span class="n">pool</span></code></pre>
</div>
<h4 id="section-5"></h4>
<p>It is also possible to launch several computations in parallel and wait for the first one to return:</p>
<div class="highlight">
<pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="o">[</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">5</span><span class="o">;</span> <span class="mi">7</span><span class="o">;</span> <span class="mi">11</span><span class="o">;</span> <span class="mi">13</span> <span class="o">]</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="nn">ThreadPoolExecutor</span><span class="p">.</span><span class="n">invoke_any</span> <span class="n">pool</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">compute</span> <span class="n">l</span><span class="o">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">others</span> <span class="o">=</span> <span class="nn">ThreadPoolExecutor</span><span class="p">.</span><span class="n">shutdown_now</span> <span class="n">pool</span> <span class="k">in</span> <span class="c">(* get all futures still running *)</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="o">(</span><span class="k">fun</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="n">ignore</span> <span class="o">(</span><span class="nn">Future</span><span class="p">.</span><span class="n">cancel</span> <span class="n">f</span> <span class="bp">true</span><span class="o">))</span> <span class="n">others</span><span class="o">;</span>
  <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;result = %d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">res</span></code></pre>
</div>
<h4 id="section-6"></h4>
<p>However, for <code>Future.cancel</code> to succeed, it is necessary for <code>compute</code> to <em>cooperate</em>: the <code>compute</code> function should periodically test whether is has been interrupted. A simple way to perform that test is to check the value returned by <code>Thread.interrupted</code> before each computation step:</p>
<div class="highlight">
<pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">compute</span> <span class="n">x</span> <span class="o">=</span>
  <span class="o">...</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">not</span> <span class="o">!</span><span class="k">done</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">not</span> <span class="o">(</span><span class="nn">Thread</span><span class="p">.</span><span class="n">interrupted</span> <span class="bp">()</span><span class="o">))</span> <span class="k">do</span>
    <span class="o">...</span>
    <span class="n">perform</span> <span class="n">computation</span> <span class="n">step</span>
    <span class="o">...</span>
  <span class="k">done</span><span class="o">;</span>
  <span class="o">...</span></code></pre>
</div>
<h4 id="section-7"></h4>
<p>Besides <em>simple</em> futures, it is also possible to use <em>scheduled</em> futures (through the <code>ScheduledFuture</code>, and <code>ScheduledThreadPoolExecutor</code> modules). It is possible to schedule a one-shot future through <code>schedule</code> by just specifying a delay before future evaluation. It is also possible to schedule a future that will be repeatedly evaluated according to a given periodicity:</p>
<ul>
<li><code>schedule_at_fixed_rate</code> allows to specify the period between two evaluation starts;</li>
<li><code>schedule_with_fixed_delay</code> allows to specify the period between one evaluation end and the next evaluation start.</li>
</ul>
<p>The following code will print <em>&quot;hello!&quot;</em> once per second:</p>
<div class="highlight">
<pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">pool</span> <span class="o">=</span>
  <span class="nn">ScheduledThreadPoolExecutor</span><span class="p">.</span><span class="n">make</span>
    <span class="o">~</span><span class="n">core_pool_size</span><span class="o">:</span><span class="mi">4</span><span class="n">l</span>
    <span class="nn">RejectedExecutionHandler</span><span class="p">.</span><span class="nc">Discard_policy</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">f</span> <span class="o">=</span>
    <span class="nn">ScheduledThreadPoolExecutor</span><span class="p">.</span><span class="n">schedule_at_fixed_rate</span>
      <span class="n">pool</span>
      <span class="n">print_endline</span> <span class="s2">&quot;hello!&quot;</span>
      <span class="mi">1</span><span class="n">L</span> <span class="mi">1</span><span class="n">L</span> <span class="nn">TimeUnit</span><span class="p">.</span><span class="nc">Seconds</span> <span class="c">(* one second before first call, one second between two calls *)</span> <span class="k">in</span>
  <span class="nn">ScheduledFuture</span><span class="p">.</span><span class="n">get</span> <span class="n">f</span><span class="o">;</span>
  <span class="nn">ScheduledThreadPoolExecutor</span><span class="p">.</span><span class="n">shutdown</span> <span class="n">pool</span></code></pre>
</div>
<h4 id="section-8"></h4>
<p>Finally, the <code>ExecutorCompletionService</code> module allows to either <em>poll</em> or <em>wait</em> until any of the submitted futures has completed evaluation.</p>
<h1 id="forkjoin-computations">Fork/join computations</h1>
<p>Fork/join computations as supported by the <code>concurrent</code> library are quite different from their Java counterpart in order to provide a less general but safer abstraction. Basically, one can turn a <em>sequential</em> function into a <em>parallel</em> one by applying a very simple divide-and-conquer strategy that is defined by:</p>
<ul>
<li>a function indicating when the passed problem (<em>i.e.</em> parameter value) should be split into sub-problems;</li>
<li>a function indicating how to combine the partial results of the sub-problems.</li>
</ul>
<p>As an exemple, a (very inefficient) way of computing the fibonacci function is:</p>
<div class="highlight">
<pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="k">rec</span> <span class="n">fib</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="k">then</span>
    <span class="mi">1</span>
  <span class="k">else</span>
    <span class="o">(</span><span class="n">fib</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">))</span> <span class="o">+</span> <span class="o">(</span><span class="n">fib</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span></code></pre>
</div>
<p>that can be turned into a parallel version through:</p>
<div class="highlight">
<pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">fork</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">threshold</span>
    <span class="k">then</span> <span class="nc">None</span> <span class="c">(* below a given value, we do not fork *)</span>
    <span class="k">else</span> <span class="nc">Some</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span> <span class="c">(* otherwise, we fork and create two subproblems *)</span>

<span class="k">let</span> <span class="n">join</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

<span class="k">let</span> <span class="n">parallel_fib</span> <span class="n">pool</span> <span class="o">=</span> <span class="nn">Concurrent</span><span class="p">.</span><span class="nn">ForkJoin</span><span class="p">.</span><span class="n">split</span> <span class="n">pool</span> <span class="n">fork</span> <span class="n">join</span> <span class="n">fib</span></code></pre>
</div>
<p>where <code>pool</code> is a value with type <code>ForkJoinPool.t</code>.</p>
<h4 id="section-9"></h4>
<p>The behaviour of <code>parallel_fib</code> when passed a value <code>x</code> is the following:</p>
<ol>
<li>evaluate <code>fork x</code>;</li>
<li>if <code>fork x</code> matches <code>None</code>, then the result for <code>parallel_fib x</code> is <code>fib x</code>;</li>
<li>if <code>fork x</code> matches <code>Some (x1, x2)</code>, then the result for <code>parallel_fib x</code> is <code>join y1 y2</code> where <code>y</code><em>i</em> is the result of <code>parallel_fib x</code><em>i</em>.</li>
</ol>
<h4 id="section-10"></h4>
<p>Besides the <code>ForkJoin.split</code> function that is based on an <code>option</code> type, the <code>ForkJoin</code> module provides similar functions based on <code>list</code>, and <code>array</code> types. They allow to divide a problem into more than two subproblems at once, possibly saving recursion steps when possible.</p>
<h1 id="mapreduce-computations">Map/reduce computations</h1>
<p>Map/reduce computations are a way to express computations through a bunch of functions:</p>
<ul>
<li><code>map : input -&gt; (key * value) list</code></li>
<li><code>combine : key -&gt; value -&gt; value -&gt; value</code></li>
<li><code>reduce : key -&gt; value -&gt; output -&gt; output</code></li>
</ul>
<p>The computation is started by providing an <code>input Stream.t</code> that is used to launch <em>map</em> computations for the stream values in different threads. Results computed by threads are then stored into a map from <code>key</code> to <code>value</code>, using <code>combine</code> to merge the values for equivalent keys. Once all <em>map</em> computations have returned, <code>reduce</code> acts as a bare fold over the aforementioned map, calculating the final result.<br />Here is how to define a map/reduce computation:</p>
<div class="highlight">
<pre><code class="language-ocaml" data-lang="ocaml"><span class="k">module</span> <span class="nc">C</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="n">input</span> <span class="o">=</span> <span class="kt">int</span>
  <span class="k">type</span> <span class="n">key</span> <span class="o">=</span> <span class="kt">int</span>
  <span class="k">type</span> <span class="k">value</span> <span class="o">=</span> <span class="kt">int</span>
  <span class="k">type</span> <span class="n">output</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span> <span class="kt">list</span>
  <span class="k">let</span> <span class="n">compare_keys</span> <span class="o">=</span> <span class="nn">Pervasives</span><span class="p">.</span><span class="n">compare</span>
    
  <span class="k">let</span> <span class="n">map</span> <span class="n">x</span> <span class="o">=</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span> <span class="n">compute</span> <span class="n">x</span><span class="o">]</span>
  <span class="k">let</span> <span class="n">combine</span> <span class="o">_</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
  <span class="k">let</span> <span class="n">reduce</span> <span class="o">_</span> <span class="n">v</span> <span class="n">acc</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">acc</span>
<span class="k">end</span></code></pre>
</div>
<p>that is then passed to the <code>MapReduce.Make</code> functor:</p>
<div class="highlight">
<pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">pool</span> <span class="o">=</span>
  <span class="nn">ThreadPoolExecutor</span><span class="p">.</span><span class="n">make</span>
    <span class="o">~</span><span class="n">core_pool_size</span><span class="o">:</span><span class="mi">4</span><span class="n">l</span>
    <span class="o">~</span><span class="n">max_pool_size</span><span class="o">:</span><span class="mi">4</span><span class="n">l</span>
    <span class="mi">1</span><span class="n">L</span> <span class="nn">TimeUnit</span><span class="p">.</span><span class="nc">Days</span>
    <span class="nn">RejectedExecutionHandler</span><span class="p">.</span><span class="nc">Discard_policy</span>

<span class="k">module</span> <span class="nc">MR</span> <span class="o">=</span> <span class="nn">MapReduce</span><span class="p">.</span><span class="nc">Make</span> <span class="o">(</span><span class="nc">C</span><span class="o">)</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">Stream</span><span class="p">.</span><span class="n">of_list</span> <span class="o">[</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">5</span><span class="o">;</span> <span class="mi">7</span><span class="o">;</span> <span class="mi">9</span><span class="o">;</span> <span class="mi">11</span><span class="o">;</span> <span class="mi">13</span><span class="o">;</span> <span class="o">...</span> <span class="o">]</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="nn">MR</span><span class="p">.</span><span class="n">compute</span> <span class="n">pool</span> <span class="n">s</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;result = %d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">res</span><span class="o">;</span>
  <span class="nn">ThreadPoolExecutor</span><span class="p">.</span><span class="n">shutdown</span> <span class="n">pool</span></code></pre>
</div>
<h1 id="parallel-arrays">Parallel arrays</h1>
<p>The <code>ParallelArray</code> module provides the same functions as the <code>Array</code> module from the standard library, except that the following ones take advantage of the multiple cores to execute operations in parallel:</p>
<ul>
<li><code>init</code>;</li>
<li><code>iter</code> and <code>iteri</code>;</li>
<li><code>fold_left</code> and <code>fold_right</code>;</li>
<li><code>sort</code>, <code>stable_sort</code>, and <code>fast_sort</code>.</li>
</ul>
<p>Of course, when using one of these functions, there is no guarantee on the order in which operations will be executed.</p>
<h4 id="section-11"></h4>
<p>The <code>ParallelArray</code> module also provides some functions with no counterpart in the <code>Array</code> module:</p>
<ul>
<li><code>mem</code> and <code>memq</code>;</li>
<li><code>exists</code> and <code>for_all</code>;</li>
<li><code>find</code>, <code>find_index</code>, and <code>fast_find_all</code>.</li>
</ul>
<h4 id="section-12"></h4>
<p>All functions accept two optional parameters:</p>
<ul>
<li><code>?pool:ThreadPoolExecutor</code> that allows to specify which thread pool to use;</li>
<li><code>?chunk_size:int</code> that allows to specify the size of the data chunks passed to the various threads.</li>
</ul>
<h4 id="section-13"></h4>
<p>In order to get rid of these optional parameters, it is possible to use the <code>ParallelArray.Make</code> functor to set the parameters once for all function calls.</p>
<div class="alert alert-warning">
<p><strong>Warning!</strong> most functions have the same signature as in the <code>Array</code> module, but it is not possible for the <em>fold</em> functions. Indeed, as folds are executed on parts of the array, an additional function is needed in order to combine the results from those partial folds. This leads to the following type for the <code>fold_left</code> function:</p>
<div class="highlight">
<pre><code class="language-ocaml" data-lang="ocaml"><span class="o">?</span><span class="n">pool</span><span class="o">:</span><span class="nn">ThreadPoolExecutor</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
<span class="o">?</span><span class="n">chunk_size</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
<span class="o">(</span><span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="c">(* original fold function *)</span>
<span class="o">(</span><span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="c">(* function used to combine results from partial folds *)</span>
<span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span>
<span class="k">&#39;</span><span class="n">b</span> <span class="kt">array</span> <span class="o">-&gt;</span>
<span class="k">&#39;</span><span class="n">a</span></code></pre>
</div>
<p>Of course, the parallel folds will yield the same results as their classical counterparts iff passed functions are associative and commutative.</p>
</div>
<h4 id="section-14"></h4>
<p>Here is an example comparing the use of <code>Array</code> and <code>ParallelArray</code>:</p>
<div class="highlight">
<pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">10000</span>

<span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="n">size</span> <span class="n">init_func</span>

<span class="k">let</span> <span class="n">sequential</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">map</span> <span class="n">compute_func</span> <span class="n">a</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">fold_left</span> <span class="o">(</span><span class="k">fun</span> <span class="n">acc</span> <span class="n">elem</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="o">(</span><span class="n">aux_func</span> <span class="n">elem</span><span class="o">))</span> <span class="mi">0</span> <span class="n">b</span> <span class="k">in</span>
  <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;result = %d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">res</span>

<span class="k">let</span> <span class="n">parallel</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="nn">ParallelArray</span><span class="p">.</span><span class="n">map</span> <span class="n">compute_func</span> <span class="n">a</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="nn">ParallelArray</span><span class="p">.</span><span class="n">fold_left</span> <span class="o">(</span><span class="k">fun</span> <span class="n">acc</span> <span class="n">elem</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="o">(</span><span class="n">aux_func</span> <span class="n">elem</span><span class="o">))</span> <span class="o">(+)</span> <span class="mi">0</span> <span class="n">b</span> <span class="k">in</span>
  <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;result = %d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">res</span><span class="o">;</span>
  <span class="nn">ParallelArray</span><span class="p">.</span><span class="n">shutdown_now</span> <span class="bp">()</span> <span class="c">(* stop threads from the default ParallelArray pool *)</span></code></pre>
</div>
<h1 id="stm">STM</h1>
<div class="alert alert-warning">
<p><strong>Warning!</strong> the current implementation has only been lightly tested.</p>
</div>
<h4 id="section-15"></h4>
<p>The <code>STM</code> module provides support for a <em>partial</em> software transactional memory. This means that the whole memory is not protected by transactions: only values of type <code>STM.ref</code> are protected. Such values are akin to <code>Pervasives.ref</code> values, and are created through the <code>STM.ref</code> function. However, those values can only be accessed from within a transaction.</p>
<h4 id="section-16"></h4>
<p>Two functions allow to process transactions:</p>
<ul>
<li><code>STM.run</code> that executes any transaction;</li>
<li><code>STM.run_read_only</code> that executes a transaction that cannot modify values.</li>
</ul>
<p>A transaction function is passed to one of these functions in order to specify the transaction behavior. The transaction function can access <code>STM.ref</code> values through accessor functions. As an example, the canonical banking account example can be written:</p>
<div class="highlight">
<pre><code class="language-ocaml" data-lang="ocaml"><span class="k">type</span> <span class="n">account</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">name</span> <span class="o">:</span> <span class="kt">string</span><span class="o">;</span> <span class="c">(* bare value *)</span>
    <span class="n">balance</span> <span class="o">:</span> <span class="kt">int</span> <span class="nn">STM</span><span class="p">.</span><span class="n">ref</span><span class="o">;</span> <span class="c">(* value protected by transactions *)</span>
  <span class="o">}</span>

<span class="k">let</span> <span class="n">make_account</span> <span class="n">n</span> <span class="n">b</span> <span class="o">=</span>
  <span class="o">{</span> <span class="n">name</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span> <span class="n">balance</span> <span class="o">=</span> <span class="nn">STM</span><span class="p">.</span><span class="n">ref</span> <span class="n">b</span> <span class="o">}</span>

<span class="k">let</span> <span class="n">print_account</span> <span class="n">acc</span> <span class="o">=</span>
  <span class="nn">STM</span><span class="p">.</span><span class="n">run_read_only</span> <span class="o">(</span><span class="k">fun</span> <span class="n">get</span> <span class="o">-&gt;</span>
    <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;%s = %dn&quot;</span> <span class="n">acc</span><span class="o">.</span><span class="n">name</span> <span class="o">(</span><span class="n">get</span> <span class="n">acc</span><span class="o">.</span><span class="n">balance</span><span class="o">))</span>

<span class="k">let</span> <span class="n">transfer</span> <span class="n">x</span> <span class="n">y</span> <span class="n">a</span> <span class="o">=</span>
  <span class="nn">STM</span><span class="p">.</span><span class="n">run</span> <span class="o">(</span><span class="k">fun</span> <span class="n">get</span> <span class="n">set</span> <span class="o">-&gt;</span>
    <span class="k">let</span> <span class="n">xv</span><span class="o">,</span> <span class="n">yv</span> <span class="o">=</span> <span class="n">get</span> <span class="n">x</span><span class="o">.</span><span class="n">balance</span><span class="o">,</span> <span class="n">get</span> <span class="n">y</span><span class="o">.</span><span class="n">balance</span> <span class="k">in</span>
    <span class="n">set</span> <span class="n">x</span><span class="o">.</span><span class="n">balance</span> <span class="o">(</span><span class="n">xv</span> <span class="o">-</span> <span class="n">a</span><span class="o">);</span>
    <span class="n">set</span> <span class="n">y</span><span class="o">.</span><span class="n">balance</span> <span class="o">(</span><span class="n">yv</span> <span class="o">+</span> <span class="n">a</span><span class="o">));</span></code></pre>
</div>

    </div>
  </div>
  <hr>
<footer>
  <p>OCaml-Java manual (version 2.0 alpha)</p>
</footer>

</div>

</body>
</html>
