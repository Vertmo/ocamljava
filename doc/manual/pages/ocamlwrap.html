<!DOCTYPE html>

<html>
<head>
<title>OCaml-Java: accessing OCaml code from the Java language</title>
<link href="../css/bootstrap.min.css" rel="stylesheet">
<style>
table {
}
</style>
</head>
<body>

<div class="container">
  <div class="row">&nbsp;</row>
  <div class="row">
    <div class="col-xs-6 col-sm-3 sidebar">
      <div class="list-group">
        
        <a href="../index.html" class="list-group-item">
          <span class="glyphicon glyphicon-home" aria-hidden="true"></span>
          &nbsp;Main page
        </a>
        
        <a href="#summary" class="list-group-item">
          <span class="glyphicon glyphicon-tag" aria-hidden="true"></span>
          &nbsp;Summary
        </a>
        
        <a href="#example" class="list-group-item">
          <span class="glyphicon glyphicon-tag" aria-hidden="true"></span>
          &nbsp;Example
        </a>
        
        <a href="#core-types" class="list-group-item">
          <span class="glyphicon glyphicon-tag" aria-hidden="true"></span>
          &nbsp;Core types
        </a>
        
        <a href="#tuples" class="list-group-item">
          <span class="glyphicon glyphicon-tag" aria-hidden="true"></span>
          &nbsp;Tuples
        </a>
        
        <a href="#functions" class="list-group-item">
          <span class="glyphicon glyphicon-tag" aria-hidden="true"></span>
          &nbsp;Functions
        </a>
        
        <a href="#exceptions" class="list-group-item">
          <span class="glyphicon glyphicon-tag" aria-hidden="true"></span>
          &nbsp;Exceptions
        </a>
        
        <a href="#sum-types" class="list-group-item">
          <span class="glyphicon glyphicon-tag" aria-hidden="true"></span>
          &nbsp;Sum types
        </a>
        
        <a href="#polymorphic-variants" class="list-group-item">
          <span class="glyphicon glyphicon-tag" aria-hidden="true"></span>
          &nbsp;Polymorphic variants
        </a>
        
        <a href="#records" class="list-group-item">
          <span class="glyphicon glyphicon-tag" aria-hidden="true"></span>
          &nbsp;Records
        </a>
        
        <a href="#polymorphism" class="list-group-item">
          <span class="glyphicon glyphicon-tag" aria-hidden="true"></span>
          &nbsp;Polymorphism
        </a>
        
        <a href="#class-types" class="list-group-item">
          <span class="glyphicon glyphicon-tag" aria-hidden="true"></span>
          &nbsp;Class types
        </a>
        
        <a href="#functors" class="list-group-item">
          <span class="glyphicon glyphicon-tag" aria-hidden="true"></span>
          &nbsp;Functors
        </a>
        
      </div>
    </div>
    <div class="col-xs-12 col-sm-9">
      <h1>OCaml-Java: accessing OCaml code from the Java language</h1>
      <hr>
      <p>This page contains the information about the <tt>ocamlwrap</tt> tool that ships with the <em>alpha</em> version of OCaml-Java 2.0.</p>
<div class="alert alert-warning">
<p><strong>Warning!</strong> <code>ocamlwrap</code> is a new tool, still at the experimental stage.</p>
</div>
<div class="alert alert-warning">
<p><strong>Warning!</strong> <code>ocamlwrap</code> does not support the typer extension allowing to access Java elements.</p>
</div>
<h1 id="summary">Summary</h1>
<p>Since version 2.0-early-access6, the distribution features the <code>ocamlwrap</code> tool in order to produce Java class definitions allowing to call <kbd>ocamljava</kbd>-compiled code from the Java language.</p>
<h4 id="section"></h4>
<p>The wrapper is invoked through a command line such as the following one:</p>
<pre><code>ocamlwrap &lt;options&gt; file1.cmi[@pack1] ... filen.cmi[@packn]</code></pre>
<p>where the optional <code><span class="citation" data-cites="packi">@packi</span></code> components can be used to specify the package for the generated class of the associated <code>cmi</code> file.</p>
<h4 id="section-1"></h4>
<p>The available options are:</p>
<table class="table table-condensed table-striped table-bordered">
<table class="table table-condensed table-striped table-bordered">
<thead>
<tr class="header">
<th style="text-align: left;">command-line switch</th>
<th style="text-align: left;">default value</th>
<th style="text-align: left;">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>-class-name-prefix &lt;string&gt;</code></td>
<td style="text-align: left;"><code>&quot;&quot;</code></td>
<td style="text-align: left;">prefix for names of generated classes</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>-class-name-suffix &lt;string&gt;</code></td>
<td style="text-align: left;"><code>&quot;Wrapper&quot;</code></td>
<td style="text-align: left;">suffix for names of generated classes</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>-library-args &lt;string&gt;</code></td>
<td style="text-align: left;"><code>new String[0]</code></td>
<td style="text-align: left;">arguments passed for library initialization</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>-library-init &lt;li&gt;</code></td>
<td style="text-align: left;"><code>explicit</code></td>
<td style="text-align: left;">library initialization mode</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>-library-package &lt;string&gt;</code></td>
<td style="text-align: left;"><em>none</em></td>
<td style="text-align: left;">library package</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>-no-warnings</code></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">whether to disable warnings</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>-package &lt;string&gt;</code></td>
<td style="text-align: left;"><code>&quot;&quot;</code></td>
<td style="text-align: left;">package of generated classes</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>-string-mapping &lt;sm&gt;         |</code>java-string<code>| mapping for OCaml</code>string<code>type             | |</code>-verbose`</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">whether to enable verbose mode</td>
</tr>
</tbody>
</table>
<p>where:</p>
<ul>
<li><code>li</code> is among <code>explit</code>, <code>static</code>;</li>
<li><code>sm</code> is among <code>java-string</code>, <code>ocamlstring</code>, <code>byte-array</code></li>
</ul>
<h4 id="section-2"></h4>
<p>The wrapper generates plain Java source files that can be read or passed to the <kbd>javadoc</kbd> tool in order to inspect the API. As the tool name suggests, <code>ocamlwrap</code> generates wrapers meaning that values are actually shared between the OCaml and Java runtimes. Side effects occuring on one side are thus observed on the other side.</p>
<h1 id="example">Example</h1>
<p>Suppose a toy library made of a single <code>Lib</code> module. The library can be compiled (as a program) using the following commands:</p>
<pre><code>ocamljava -java-package wraptest -c lib.mli
ocamljava -java-package wraptest -c lib.ml
ocamljava -java-package wraptest -o lib.jar lib.cmj</code></pre>
<p>and Java wrappers can be generated by executing:</p>
<pre><code>ocamlwrap lib.cmi</code></pre>
<p>that will result in a new <code>LibWrapper.java</code> file.</p>
<h4 id="section-3"></h4>
<p>Then, it is possible to use the functions exposed in the <code>lib.mli</code> file from Java through the <code>LibWrapper.java</code> file, that can be compiled through:</p>
<pre><code>javac -cp lib.jar LibWrapper.java</code></pre>
<h4 id="section-4"></h4>
<p>For example, if <code>lib.mli</code> contains the following declarations:</p>
<pre><code>type connection = {
  login : string;
  mutable timestamp : int64;
}
val connections_to : string -&gt; connection list</code></pre>
<p>then, the Java code can look like:</p>
<pre><code>public static void main(String[] args) throws Exception {
    wraptest.ocamljavaMain.mainWithReturn(args);

    ...

    for (LibWrapper.connection c : LibWrapper.connections_to(&quot;...&quot;)) {
        log.printf(&quot;user %s since %d\n&quot;, c.getLogin(), c.getTimestamp());
    }
}</code></pre>
<p>where the first line of the <code>main</code> method is mandatory, and responsible for calling the initialization code of the OCaml library. The following sections show how the various elements of a <code>mli</code> file are mapped to their Java equivalents.</p>
<h1 id="core-types">Core types</h1>
<p>The core (or predefined) types of the OCaml language are mapped as follows:</p>
<table class="table table-condensed table-striped table-bordered">
<thead>
<tr class="header">
<th style="text-align: left;">OCaml type</th>
<th style="text-align: left;">Java type (boxed)</th>
<th style="text-align: left;">Java type (unboxed)</th>
<th style="text-align: left;">implemented interfaces</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>OCamlInt</code></td>
<td style="text-align: left;"><code>long</code></td>
<td style="text-align: left;"><code>OCamlNumber</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>char</code></td>
<td style="text-align: left;"><code>OCamlChar</code></td>
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;">-</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>string</code></td>
<td style="text-align: left;"><code>OCamlString</code></td>
<td style="text-align: left;">(1)</td>
<td style="text-align: left;"><code>CharSequence</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>float</code></td>
<td style="text-align: left;"><code>OCamlFloat</code></td>
<td style="text-align: left;"><code>double</code></td>
<td style="text-align: left;"><code>OCamlNumber</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>bool</code></td>
<td style="text-align: left;"><code>OCamlBool</code></td>
<td style="text-align: left;"><code>boolean</code></td>
<td style="text-align: left;">-</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>unit</code></td>
<td style="text-align: left;"><code>OCamlUnit</code></td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>int32</code></td>
<td style="text-align: left;"><code>OCamlInt32</code></td>
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>OCamlNumber</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>int64</code></td>
<td style="text-align: left;"><code>OCamlInt64</code></td>
<td style="text-align: left;"><code>long</code></td>
<td style="text-align: left;"><code>OCamlNumber</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>nativeint</code></td>
<td style="text-align: left;"><code>OCamlNativeInt</code></td>
<td style="text-align: left;"><code>long</code></td>
<td style="text-align: left;"><code>OCamlNumber</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>'a option</code></td>
<td style="text-align: left;"><code>OCamlOption&lt;T&gt;</code></td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>'a lazy_t</code></td>
<td style="text-align: left;"><code>OCamlLazy&lt;T&gt;</code></td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>'a array</code></td>
<td style="text-align: left;"><code>OCamlArray&lt;T&gt;</code></td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><code>Iterable&lt;T&gt;</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>'a list</code></td>
<td style="text-align: left;"><code>OCamlList&lt;T&gt;</code></td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><code>Iterable&lt;T&gt;</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>'a ref</code></td>
<td style="text-align: left;"><code>OCamlRef&lt;T&gt;</code></td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>in_channel</code></td>
<td style="text-align: left;"><code>OCamlInChannel</code></td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>out_channel</code></td>
<td style="text-align: left;"><code>OCamlOutChannel</code></td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
</tr>
</tbody>
</table>
<ol type="1">
<li>depends on <kbd>-string-mapping</kbd></li>
</ol>
<h4 id="section-5"></h4>
<p>The <code>javadoc</code>-generated documentation for all predefined classes is available in the <code>doc</code> directory of the distribution.</p>
<div class="alert alert-warning">
<p><strong>Warning!</strong> All operations on OCaml channels are buffered. It is thus necessary to flush channels at appropriate points when the same channel/stream is used on both OCaml and Java sides.</p>
</div>
<h1 id="tuples">Tuples</h1>
<p>All OCaml tuples are mapped to Java classes with names <code>OCamlTuple</code><em>N</em>, where <em>N</em> is the tuple size. This means, for example, that the OCaml type <code>int * float</code> is mapped to the Java type <code>OCamlTuple2&lt;OCamlInt, OCamlFloat&gt;</code>. The current implementation only supports tuples up to size 8.</p>
<h4 id="section-6"></h4>
<p>It is important to notice that the class <code>OCamlTuple</code><em>N</em> does not inherit from any of the class <code>OCamlTuple</code><em>K</em> where <em>K</em> &lt; <em>N</em>. This is consistent with the fact that it is illegal in OCaml to pass a triple where a couple is actually waited.</p>
<h1 id="functions">Functions</h1>
<p>Functions are translated in two different ways:</p>
<ul>
<li>as static methods if they are top-level functions of the module passed to the <code>ocamlwrap</code> tool;</li>
<li>as instances of classes with names <code>OCamlFunction</code><em>N</em><code>&lt;</code><em>T1</em>, ..., <em>Tn</em>, <em>TR</em><code>&gt;</code> (where <em>TR</em> is the return type, while the <em>Ti</em> are the parameter types).
</li></li>
</ul>
<p>In the first case, the function is invoked by a call such as <code>LibWrapper.f(p1, ..., pn)</code>, while in the second case the function should be invoked by a call such as <code>f.execute(p1, ..., pn)</code>. <code>OCamlFunction</code><em>N</em> classes are akin to <code>OCamlTuple</code><em>N</em> classes (except that <em>N</em> is only up to 5), but are abstract classes. A concrete implementation is typically retrieved by:</p>
<ul>
<li>getting the result of a function;</li>
<li>calling <code>LibWrapper.f$closure()</code> to get the instance associated with top-level function <code>LibWrapper.f</code>;</li>
<li>implementing it in the Java language by extending an <code>OCamlFunction</code><em>N</em> class (the only method to implement being <code>execute(...)</code>).</li>
</ul>
<h4 id="section-7"></h4>
<p>For example, if the OCaml code defines a function with the following signature:</p>
<pre><code>val call : (int -&gt; int -&gt; string) -&gt; string</code></pre>
<p>it is possible to invoke it with an instance of <code>OCamlFunction2&lt;OCamlInt,OCamlInt,OCamlString&gt;</code> through:</p>
<pre><code>OCamlString s = LibWrapper.call(new OCamlFunction2&lt;OCamlInt, OCamlInt, OCamlString&gt;() {
    public OCamlString execute(OCamlInt p0, OCamlInt p1) {
       ...
       return OCamlString.create(&quot;...&quot;);
    }
});</code></pre>
<h1 id="exceptions">Exceptions</h1>
<p>The <code>ocamlwrap</code> tool takes care of converting exceptions between their OCaml and Java representations where needed. As a consequence, the developer only needs to know the mappings between OCaml and Java exceptions (see table below); catching and raising exceptions is done by manipulating the Java exceptions as usual.</p>
<table class="table table-condensed table-striped table-bordered">
<thead>
<tr class="header">
<th style="text-align: left;">OCaml exception</th>
<th style="text-align: left;">Java exception</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>Assert_failure</code></td>
<td style="text-align: left;"><code>OCamlAssertFailureException</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Division_by_zero</code></td>
<td style="text-align: left;"><code>OCamlDivisionByZeroException</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>End_of_file</code></td>
<td style="text-align: left;"><code>OCamlEndOfFileException</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Failure</code></td>
<td style="text-align: left;"><code>OCamlFailureException</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Invalid_argument</code></td>
<td style="text-align: left;"><code>OCamlInvalidArgumentException</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Match_failure</code></td>
<td style="text-align: left;"><code>OCamlMatchFailureException</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Not_found</code></td>
<td style="text-align: left;"><code>OCamlNotFoundException</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Out_of_memory</code></td>
<td style="text-align: left;"><code>OCamlOutOfMemoryException</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Stack_overflow</code></td>
<td style="text-align: left;"><code>OCamlStackOverflowException</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Sys_blocked_io</code></td>
<td style="text-align: left;"><code>OCamlSysBlockedIOException</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Sys_error</code></td>
<td style="text-align: left;"><code>OCamlSysErrorException</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Undefined_recursive_module</code></td>
<td style="text-align: left;"><code>OCamlUndefinedRecursiveModuleException</code></td>
</tr>
</tbody>
</table>
<h4 id="section-8"></h4>
<p>Additionally, the <code>OCamlExn</code> class is used as the mapping for the OCaml <code>exn</code> type.</p>
<h1 id="sum-types">Sum types</h1>
<p>An OCaml sum type is mapped to a Java class providing factory methods to create the various cases, and accessors for each nested value of each case. For example, the following type:</p>
<pre><code>type sum =
  | Int of int
  | String of string
  | Empty
  | Int_and_string of int * string</code></pre>
<p>is mapped to the class:</p>
<pre><code>class sum extends OCamlValue {
  public long getInt0();
  public String getString0();
  public long getInt_and_string0();
  public String getInt_and_string1();
  public TAG tag();
  public static sum createInt(long);
  public static sum createString(String);
  public static sum createEmpty();
  public static sum createInt_and_string(long, String);
  public static enum TAG { Int, String, Empty, Int_and_string }
  public &lt;T&gt; T visit(Visitor&lt;T&gt; visitor);
}</code></pre>
<p>where the inner-class <code>TAG</code> is used to encode the various cases as a Java enum.</p>
<h4 id="section-9"></h4>
<p>The <code>visit</code> method allows to inspect the value through the <em>visitor</em> design pattern, with the <code>Visitor</code> interface generated for the sum type; in out example:</p>
<pre><code>interface Visitor&lt;T&gt; {
  T visitInt(long);
  T visitString(String);
  T visitEmpty();
  T visitInt_and_string(long, String);
}</code></pre>
<p>The use of the visitor design pattern should be prefered to the use of the <code>tag</code> and accessor methods, as it provides guarantees close to the ones provided by OCaml pattern matching:</p>
<ul>
<li>exhaustivity;</li>
<li>correct access to nested values.</li>
</ul>
<h1 id="polymorphic-variants">Polymorphic variants</h1>
<p>The current version of <kbd>ocamlwrap</kbd> requires that polymorphic variants:</p>
<ul>
<li>are closed;</li>
<li>have their type declared.</li>
</ul>
<p>This means that one should declare:</p>
<pre><code>type t = [ `A | `B of int ]
val f : int -&gt; t</code></pre>
<p>rather than:</p>
<pre><code>val f : int -&gt; [ `A | `B of int ]</code></pre>
<h4 id="section-10"></h4>
<p>The combination of both aforementioned restrictions allows to treat polymorphic variants as bare sum types.</p>
<h1 id="records">Records</h1>
<p>The mapping of records is straightforward, following the convention of JavaBeans. This means that for each field named <code>xyz</code>, an accessor named <code>getXyz()</code> is generated allowing to retrieve the field value. If the field is mutable, another accesor named <code>setXyz(...)</code> is also generated allowing to modify the field value.</p>
<h4 id="section-11"></h4>
<p>For example, if the following record is defined in OCaml:</p>
<pre><code>type connection = {
  login : string;
  mutable timestamp : int64;
}</code></pre>
<p>it will result in the following Java class:</p>
<pre><code>class connection extends OCamlValue {
  public String getLogin();
  public long getTimestamp();
  public void setTimestamp(long);
  public static connection create(String, long);
}</code></pre>
<p>where the <code>create(...)</code> method is a factory method allowing to create new instances.</p>
<h1 id="polymorphism">Polymorphism</h1>
<p>The <kbd>ocamlwrap</kbd> tool supports polymorphism both in type declarations, and in function declarations. However, the <kbd>ocamlwrap</kbd> tool is not always able to determine how to wrap a value. When this occurs, the generated Java methods will ask for additional parameters with types <code>Wrapper&lt;T&gt;</code>. An instance of <code>Wrapper&lt;T&gt;</code> is just an object that knows how to wrap a value into type <code>T</code>.</p>
<h4 id="section-12"></h4>
<p>Every Java class mapping an OCaml type provides a <code>wrapper</code> method allowing to retrieve a wrapper. If the OCaml type has no type parameter, the <code>wrapper</code> method takes no parameter (<em>e.g.</em> <code>OCamlInt.wrapper()</code>). Otherwise, the <code>wrapper</code> method should be passed a wrapper for each type parameter, leading for example to:</p>
<ul>
<li><code>OCamlList.wrapper(OCamlString.wrapper())</code> to get a wrapper for type <code>string list</code>;</li>
<li><code>OCamlTuple2.wrapper(OCamlInt32.wrapper(), OCamlInt64.wrapper())</code> to get a wrapper for type <code>int32 * int64</code>.</li>
</ul>
<h1 id="class-types">Class types</h1>
<p>The current version of <kbd>ocamlwrap</kbd> provides only partial support for OCaml objects: it is only possible to wrap class types (meaning that classes and <em>immediate</em> objects are not supported).</p>
<h4 id="section-13"></h4>
<p>OCaml class types are mapped to Java abstract classes. For example, the following:</p>
<pre><code>class type simple = object
  method first_method : unit
  method second_method : int -&gt; float
  method third_method : int32
end</code></pre>
<p>is mapped to:</p>
<pre><code>abstract class simple extends OCamlValue {
  public abstract void first_method() ;
  public abstract double second_method(long) ;
  public abstract int third_method() ;
}</code></pre>
<h4 id="section-14"></h4>
<p>There are essentially two ways of getting an instance of such a class:</p>
<ul>
<li>as the result of an OCaml function;</li>
<li>as the instance of a Java class inheriting from the abstract one.</li>
</ul>
<p>In the second case, a concrete Java class is defined as usual:</p>
<pre><code>class MySimple extends LibWrapper.simple {
  public void first_method() { System.out.println(&quot;in first method&quot;); }
  public double second_method(long x) { return ((double) x) / 10.0; }
  public int third_method() { return 1; }
}</code></pre>
<h4 id="section-15"></h4>
<div class="alert alert-warning">
<p><strong>Warning!</strong> Currently, class types can neither inherit from other class types, nor contain values.</p>
</div>
<h1 id="functors">Functors</h1>
<p>The current version of <code>ocamlwrap</code> provides only lightweight support for OCaml functors, and module types can only contain functions and abstract type definitions. The mapping of module types is very similar to the one of class types, except that type declarations appear as generics. For example:</p>
<pre><code>module type MT1 = sig
  type t
  val cost : t -&gt; int
end</code></pre>
<p>is mapped to:</p>
<pre><code>abstract class MT1&lt;t extends OCamlValue&gt; extends OCamlValue {
  public abstract long cost(t) ;
}</code></pre>
<h4 id="section-16"></h4>
<p>The declaration of functors requires that all involved module types have been previously declared, thus leading to definitions like:</p>
<pre><code>module type P = sig ... end
module type R = sig ... end
module M (X : P) : R with type ...</code></pre>
<p>rather than:</p>
<pre><code>module M (X : sig ... end) : sig ... end</code></pre>
<p>Functors are mapped to static methods, just like ordinary top-level functions.</p>
<h4 id="section-17"></h4>
<p>It is possible to mix OCaml and Java by instantiating a functor whose parameters have been implemented in Java. For example, considering the following OCaml declarations:</p>
<pre><code>module type MT1 = sig
  type t
  val cost : t -&gt; int
end

module type MT2 = sig
  type element
  type container
  val make : unit -&gt; container
  val add : container -&gt; element -&gt; unit
  val total : container -&gt; int
end

module Make (P : MT1) : MT2 with type element = P.t</code></pre>
<p>It is possible to develop an implementation for <code>MT1</code> in Java:</p>
<pre><code>class MT1Impl extends LibWrapper.MT1&lt;OCamlString&gt; {
  public MT1Impl() {
    super(OCamlString.WRAPPER);
  }
  public long cost(OCamlString s) {
    long res = 0L;
    int len = s.length();
    for (int i = 0; i &lt; len; i++) {
      char ch = s.charAt(i);
      if (ch == &#39;e&#39;) res++;
    }
    return res;
  }
}</code></pre>
<p>And to pass it to the OCaml functor:</p>
<pre><code>MT1Impl mt1 = new MT1Impl();
LibWrapper.MT2&lt;OCamlString,OCamlValue&gt; mt2 = LibWrapper.Make(mt1);
OCamlValue container = mt2.make();
mt2.add(container, OCamlString.create(&quot;abc&quot;));
mt2.add(container, OCamlString.create(&quot;def&quot;));
mt2.add(container, OCamlString.create(&quot;ghi&quot;));
System.out.printf(&quot;total=%d\n&quot;, mt2.total(container));</code></pre>
<h4 id="section-18"></h4>
<div class="alert alert-warning">
<p><strong>Warning!</strong> Contrary to other elements, the use of functors heavily relies on developer discipline. Indeed, in OCaml, applications of a functor to different parameters lead to different modules where embedded types are different from one application to the other. It is not possible to reflect these differences in the Java wrappers, thus leading to the possibility to mix the values generated by different functor applications, hence in turn breaking type safety.</p>

    </div>
  </div>
  <hr>
<footer>
  <p>OCaml-Java manual (version 2.0 alpha)</p>
</footer>

</div>

</body>
</html>
